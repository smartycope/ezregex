TODO (these are in order):
er.underscore
er.anyQuote
add ezregex.org to the homepage link in PyPi
I don't think punctuation has all of the punctuation chars
\number -- Matches the contents of the group of the same number. Groups are numbered starting from 1. For example, (.+) \1 matches 'the the' or '55 55', but not 'thethe' (note the space after the group). This special sequence can only be used to match one of the first 99 groups. If the first digit of number is 0, or number is 3 octal digits long, it will not be interpreted as a group match, but as the character with octal value number. Inside the '[' and ']' of a character class, all numeric escapes are treated as characters.
(?(id/name)yes-pattern|no-pattern) -- Will try to match with yes-pattern if the group with given id or name exists, and with no-pattern if it doesn’t. no-pattern is optional and can be omitted. For example, (<)?(\w+@\w+(?:\.\w+)+)(?(1)>|$) is a poor email matching pattern, which will match with '<user@host.com>' as well as 'user@host.com', but not with '<user@host.com' nor 'user@host.com>'.
nested_expr(opener, closer, content=None, ignore_expr=quoted_string) - method for defining nested lists enclosed in opening and closing delimiters.
something like a word(letters=n) or something, including \b word{3} \b
maybe change conditionals to taking in 2 parameters (the current pattern, and their associated condition) instead
(?P=name) -- A backreference to a named group; it matches whatever text was matched by the earlier group named name.
all the methods which return NotImplemented
(?:(?:a|b)|c) does not do the same as ((a|b)|c). Why? Is this intentional?
operators: |, &, ^, ~
wordStart/wordEnd/wordStartsWith/wordEndsWith (\b and \</\>?)
maybe a function like line(stuff in a line), which automatically adds line start and line end to it
& and `and` operator -- Each
Add these https://pyparsing-docs.readthedocs.io/en/latest/HowToUsePyparsing.html#expression-operators
DelimitedList - used for matching one or more occurrences of expr, separated by delim.
^ and `or` operator -- anyof
CaselessLiteral - construct with a string to be matched, but without case checking; results are always returned as the defining literal, NOT as they are found in the input string
caseless_literal -- a caseless function that makes only the specified chain case-insensitive. Might only work on a few funtions?
nested groups (i.e. matchMax(group(comma))) will only match the last one. Add some way to fix that?
dialects?: http://web.archive.org/web/20080512021636/http://www.erudil.com/preqr.pdf
QuotedString - supports the definition of custom quoted string formats, in addition to pyparsing’s built-in dbl_quoted_string and sgl_quoted_string. QuotedString allows you to specify the following parameters:
Keyword - similar to Literal, but must be immediately followed by whitespace, punctuation, or other non-keyword characters; prevents accidental matching of a non-keyword that happens to begin with a defined keyword
arith_op
These https://pyparsing-docs.readthedocs.io/en/latest/HowToUsePyparsing.html#common-string-and-token-constants
empty -- matches an empty string in an expression. useful for something like empty + ifFollowedBy(...)
expr[...:end_expr] is equivalent to ZeroOrMore(expr, stop_on=end_expr)
CaselessKeyword - similar to Keyword, but with caseless matching behavior as described in CaselessLiteral.
ungroup
referenceGroup = EZRegexMember(lambda cur, name:        f'{cur}(?P={name})')
NotAny - a negative lookahead expression, prevents matching of named expressions, does not advance the parsing position within the input string; can also be created using the unary ‘~’ operator
is matchMax(either('a', 'b')) supposed to match 'aba' or just 'aaa' or 'bbb'?
quote_char - string of one or more characters defining the quote delimiting string
emoji() member
Everything on https://pyparsing-docs.readthedocs.io/en/latest/HowToUsePyparsing.html#basic-parserelement-subclasses for compatibility
(?>...) -- Attempts to match ... as if it was a separate regular expression, and if successful, continues to match the rest of the pattern following it. If the subsequent pattern fails to match, the stack can only be unwound to a point before the (?>...) because once exited, the expression, known as an atomic group, has thrown away all stack points within itself. Thus, (?>.*). would never match anything because first the .* would match all characters possible, then, having nothing left to match, the final . would fail to match. Since there are no stack points saved in the Atomic Group, and there is no stack point before it, the entire expression would thus fail to match.
more flags listed under https://pypi.org/project/regex/ under "Flags".
content - expression for items within the nested lists (default=None)


BUGS:
AnyExcept tests are currently failing == AnyExcept: ^(?!.*county).* (matches any line which doesn't have 'county' in it)
| operator isn't working for some reason
try matchRange(0, 3, digit) matching 8888888, and see how many matches it finds
invert, when matching upper and lowercase, seem to only choose a or z
Invert is failing some tests

ADD TESTS FOR:
Way more tests for replacement
Fix anyExcept, but of a specific type (i.e. anything which is a word, but not in args)
docs
punctuation
All the todos in tests
<<=, >>=
some psuedonymns
more flags
handle the deprication warnings
wordBoundary
notWordBoundary

ADD DOCS FOR:
alphas
alphanum
punctuation
one_of
white
unary + operator
anyExcept, but of a specific type (i.e. anything which is a word, but not in args)
[] operators
matchAtMost
~ operator
wordBoundary
notWordBoundary
remove group, add namedGroup deprication
add [] operators!
    https://pyparsing-docs.readthedocs.io/en/latest/HowToUsePyparsing.html
    expr[2, 3] is equivalent to expr + expr + Opt(expr)
    expr[n, ...] or expr[n,] is equivalent to expr*n + ZeroOrMore(expr) (read as “at least n instances of expr”)
    expr[... ,n] is equivalent to expr*(0, n) (read as “0 to n instances of expr”)
    expr[...], expr[0, ...] and expr * ... are equivalent to ZeroOrMore(expr)
    expr[1, ...] is equivalent to OneOrMore(expr)

ADD INVERTS FOR:
literallyAnything is broken, so I assume either is broken as well
`word + letter + group(word + ow) + '()'`` doesn't invert

TO INVESTIGATE:
    p = wordChar; s = '5_5';
        not enough matches presented, and splitting seems off
